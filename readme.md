# Design Patterns 

## Introduction to Design Patterns (Python based)

Design Patterns are typical solutions to common problems in software design. Each pattern is like a blueprint that you can customize to solve a particular design problem in your code. They are not finished designs that can be transformed directly into code but are templates for how to solve a problem in various situations.
Design patterns gained popularity in computer science after the book Design Patterns: Elements of Reusable Object-Oriented Software was published in 1994 by the so-called "Gang of Four" (Gamma et al.). 

![image](https://github.com/ishwar6/design_patterns/assets/41536582/4eefd286-3a5e-4185-b0c3-e46335fe8efb)

## Why Use Design Patterns?

1. **Solutions to Common Problems**: Design patterns provide solutions to common software design issues. They are based on proven techniques and provide a standard terminology.
2. **Best Practices**: Using design patterns means employing industry best practices, enhancing code readability and reliability.
3. **Communication**: Design patterns provide a standard terminology and are specific to particular scenarios, making it easier for software developers to communicate.
4. **Scalability and Maintainability**: Patterns allow the design to be scalable and maintainable with less effort and cost.

## Types of Design Patterns

Design patterns can be categorized into three types:

### 1. Creational Patterns
These patterns provide various object creation mechanisms, which increase flexibility and reuse of existing code.
- **Singleton**: Ensures a class has only one instance and provides a global point of access to it.
- **Builder**: Constructs a complex object step by step.
- **Prototype**: Creates new objects by copying an existing object.
- **Factory Method**: Creates an instance of several derived classes.
- **Abstract Factory**: Creates an instance of several families of classes.

### 2. Structural Patterns
These patterns explain how to assemble objects and classes into larger structures, while keeping these structures flexible and efficient.
- **Adapter**: Allows incompatible interfaces to work together.
- **Bridge**: Separates an object’s interface from its implementation.
- **Composite**: Composes objects into tree structures to represent part-whole hierarchies.
- **Decorator**: Adds new functionalities to an object dynamically.
- **Facade**: Provides a simplified interface to a complex subsystem.
- **Flyweight**: Reduces the cost of creating and manipulating a large number of similar objects.
- **Proxy**: Provides a surrogate or placeholder for another object to control access to it.

### 3. Behavioral Patterns
These patterns are concerned with algorithms and the assignment of responsibilities between objects.
- **Chain of Responsibility**: Passes a request along a chain of handlers.
- **Command**: Encapsulates a command request as an object.
- **Interpreter**: Implements a specialized language.
- **Iterator**: Sequentially accesses the elements of a collection.
- **Mediator**: Defines simplified communication between classes.
- **Memento**: Captures and externalizes an object’s internal state.
- **Observer**: A way of notifying change to several classes.
- **State**: Allows an object to alter its behavior when its internal state changes.
- **Strategy**: Allows one of a family of algorithms to be selected on-the-fly at runtime.
- **Template Method**: Defines the skeleton of an algorithm in an operation.
- **Visitor**: Separates an algorithm from an object structure.

## Conclusion

Design patterns are crucial for creating robust, scalable, and maintainable software. They provide solutions to common problems faced in software design and help to accelerate the development process. 

### Criticism: 
 - http://www.paulgraham.com/icad.html
---

